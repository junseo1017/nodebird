전통적인 SSR 방식
브라우저 <-> 프론트 서버 <-> 백엔드 서버 <-> 데이터베이스

SPA(CSR) 방식의 경우, 브라우저에서 요청이 발생했을 떄 프론트에서는 로딩창을 띄우고 백엔드에서 바로 데이터를 받아와서 화면에 띄움


SSR / CSR 방식의 장단점

SSR의 장점
: 화면 전체가 한번에 그려지지만 로딩 속도가 김

CSR의 장점 < 리액트를 쓰는 이유
: 일단 로딩창이라도 띄울 수 있기 때문에 사용자 경험에서 좋음
: 화면에 뭐라도 보이는 시간이 단축됨.
 
단점
: 페이지에 방문했을 때 로딩창이 뜨면 검색 엔진에서 노출이 덜 될 수 있음.

서버 사이드 렌더링 2가지 종류 : 
프리렌더 
서버 사이드 렌더링 : 첫 방문만 서버 사이드, 그 다음부터는 SPA로 

서버 사이드 렌더링과 코드 스플리팅을 적용해야함.
: 검색 엔진을 신경써야 함.
: 사용자를 대상으로 하는 페이지는 속도가 중요하니까 코드 스플리팅해줘야 함.


Next.js를 어떨 때 써야 할까?
: 왠만한 B2C 서비스를 할 때는 NEXT같은 서버 사이드 렌더링을 지원하는 프레임워크를 사용해야 함.

NEXT의 특징
: 첫 방문은 약간의 로딩이 있지만, 이후로는 로딩이 전혀 없다. 
: 클릭할만한 링크가 있으면 미리 받아와줌 (프리 패칭)

next에서는 react router는 쓰이지 않음 (자체적인 라우터가 있음 link)
next에는 react hot loader까지 적용되어 있음

---

개발 중일때는 NEXT 개발 모드이기 때문에 약간 느릴 수 있음
배포모드일때는 빨리지니까 걱정ㄴ

---

머터리얼 / 앤트디 / 부트스트랩 : 선호도 차이

---

다이나믹 라우팅, API 라우팅이 넥스트에 내장됨으로서
커스텀 프론트 서버를 만들 필요가 없음

---

브라우저 - 백엔드간 요청에  CORS 설정이 필요함.
서버 사이드 렌더링할 때
백엔드 서버와 프론트 서버의 도메인이 다르기 때문에, 포트만 달라도 CORS에 걸림
CORS 설정해줘야 함.
프론트에서도 쿠키 보내는거 withCredentials 옵션 설정해줘야함

---

실무는 서버를 두개(프론트 서버, 백엔드 서버)를 둠

CSR 요청 순서 : 브라우저 > 프론트 서버 > 브라우저 > 백엔드 서버 > 브라우저
SSR 요청 순서 : 브라우저 > 프론트 서버 > 백엔드 서버 > 프론트 서버 > 브라우저

---

mongoDB보다 sql쓰는게 나음
이유 : 데이터들간에 무조건 관계가 있음.
로그 쌓을 때 mongoDB가 좋음.

---

next안에 webpack이 내장되어 있음
webpack이 css를 보면 스타일로 html에 넣어줌

---

**컴포넌트에 프롭스로 넘겨주는 함수는 useCallback을 꼭 써줘야 최적화가 된다.**

--

tag에 직접 style을 주면 
리렌더링이 발생
왜냐하면 객체 === 객체는 false이기 때문에
이럴 때 스타일드 컴포넌트씀 렌더링 다시 안시킴

또는 useMemo에 style 변수를 따로 캐싱시키고 jsx에 직접넣을 수 있음
const style = useMemo(()=>({marginTop:10}),[])

---

함수형 컴포넌트에서 리렌더링된다는 건 함수의 처음부터 끝까지 다시 실행됨.
useCallback, useMemo는 리렌더링 되지 않음 (바뀐게 없다면)
jsx에서 바뀐 부분이 있다면 바뀐 부분만 다시 렌더링함


---

return 부분 virtual dom이라고 생각하면됨
리액트에서 한 번 그려주고 리렌더링이 됐을 때 VRDOM으로 된게 이전 컴포넌트와 지금 컴포넌트의 가상돔을 비교해서 
차이를 인식하면 그 부분만 다시 그림. 

---

antd의 form의 onFinish이벤트는 이미 preventDefault가 적용되어 있음

---

리렌더링 된다고해서 성능에 문제가 있는 건 아님.

----

코딩 처음에 할 때 하나하나 html 작성하지말고 컴포넌트 구현 안했더라도 그냥 컴포넌트 어떻게 넣을지부터 정해보기

---

100줄 넘어가면 컴포넌트 분리하자.
같은 성격의 다른 데이터를 다루는 컴포넌트라면 props의 개수로 컴포넌트를 따로 만들지 고민하자 prop의 갯수가 적당하다면 그냥 같은걸로 쓰자.

---

hook은 반복문 조건문 함수 내에서 사용 x 
컴포넌트 안에서만 사용 가능
하지만 커스텀 훅은 에외임

---

컴포넌트는 최대한 화면에 집중하도록 하자.
데이터 요청/관리는 중앙저장소에서.

컴포넌트의 데이터는 부모로부터 받거나, hook으로 받고 화면만 그리기

---

